---
title:  "[Book] Java의 정석"
excerpt: "Java"

categories:
  - IT
tags:
  - [IT, Java]

toc: true   # table of contents
toc_sticky: true

author_profile: false   # 좌측 프로필 접기(포스트에 들어가면 꺼짐)
sidebar:
  nav: "docs"

date: 2023-07-21
last_modified_at: 2022-07-21
---

## **변수(Variable)**

데이터는 메모리에 저장된다.

**값을 저장할 수 있는 메모리의 공간**을 의미함.

변수는 복수 개의 값을 저장할 수 없고, 하나의 값만 저장 가능하다.

## **변수의 선언**

**타입**은 변수에 저장되는 값의 종류와 범위를 결정짓는 요소

변수 이름은 **메모리 주소에 붙여진 이름**이다.

```java
int age;
//변수타입 변수이름

//초기화: 변수를 사용하기 전 처음으로 값을 저장하는 것
int age = 25;
// 초기화를 하지 않는 경우 쓰레기값이 남아 있을 수 있어 주의
```

변수명은 naming convention에 따라야 한다.

### Naming convention

- 첫번째 글자는 문자이거나 $, _ 이어야하고 숫자로 시작할 할 수 없다.
- 대소문자 구분된다.
- 길이 제한은 없다.
- 자바 예약어는 사용할 수 없다.

변수명은 해당 이름을 보고 이 변수가 어떤 값을 저장하는지 쉽게 알 수 있도록 하는것이 좋다.

### Java  권장 명명규칙(관례)

- 클래스 이름의 첫 글자는 대문자
- 상수의 이름은 대문자, 여러 단어가 연결된 경우 _로 구분
- 첫 문자는 소문자로 시작하고 다른 단어가 붙을 경우 첫 문자를 대문자로 한다

## 변수의 타입

기본형과 참조형이 존재

기본형: 실제 값을 저장

참조형: 객체의 주소를 저장

**변수값 저장**

변수 값을 저장할때는 대입연산자(=)를 사용한다.

## 상수와 리터럴

상수(Constant): 값을 저장할 수 있는 공간이지만, **한번 저장하면 다른 값으로 변경할 수 없다**.

반드시 선언과 동시에 초기화해야함

final 키워드를 사용하여 선언

```java
final int MAX_SPEED = 10;
```

리터럴(Literal): 원래는 일반적인 값 그 자체가 상수를 뜻하지만, 위에 한번 선언하면 변경할 수 없는 저장공간(Constant)과 비교하기 위해 붙인 이름

### **정수 타입(byte, char, short, int, long)**

**int**

자바는 **기본적으로 정수 연산을 int 타입**으로 수행

저장하려는 변수가 특별한 이유가 없는 한 int 타입 변수에 저장하는 것이 좋다.(JVM에서 연산할때 4byte로 변환하여 연산, 자체 4byte인 int가 연산에 유리)

**String(reference type)**

String 타입은 기본 타입이 아니다.

String은 클래스 타입이고 String 변수는 참조 변수이다.

문자열이 변수에 직접 저장되는 것이 아니라, String 객체가 생성되고 변수는 객체의 번지를 참조함.

**char**

char 타입에는 ‘’ 빈 문자를 대입시 컴파일 에러 발생, 공백을 저장하고 싶은 경우 유니코드 32로 초기화 해야한다.

**long**

long 타입은 큰 정수값을 저장할때 사용하며, 뒤에 L을 붙여서 사용함(소문자는 1과 혼동하기 쉬워 사용자제)

**double, float**

실수는 부동소수점(floating-point) 방식으로 저장

기본적으로 double로 간주, double이 float 보다 정밀한 계산할때 사용

double 타입은 뒤에 D나 d를 붙여준다.

float 타입은 리터럴 뒤에 f 나 F를 붙여준다.

## 출력

화면에 표출하는 방법

지시자(specifier)를 사용하여 변수도 출력 할 수 있다.

- printf(): 출력만 진행
- println(): 출력 후 줄바꿈

| 지시자 | 설명 |
| --- | --- |
| %b | boolean형식 출력 |
| %d | decimal(10진수) 형식 출력 |
| %o | octal(8진수) 형식 출력 |
| %x, %X | hexa-decimal(16진수) 형식 출력 |
| %f | floating-point 형식 출력 |
| %e. %E | exponent 형식 출력 |
| %c | character 형식 출력 |
| %s | String 출력 |

## 입력

화면에서 값을 입력 받기

```java
import java.util.*;

// Scanner클래스의 객체를 생성
Scanner scanner = new Scanner(System.in)

String input = scanner.nextLine(); // .nextInt()도 가능
int num = Integer.parseInt(input);
```

## 기본형

**정수 리터럴**

소수점 없는 정수는 10진수로 간주

0으로 시작하는 리터럴은 8진수로 간주

0x 또는 0X로 시작하는 리터럴은 16진수로 간주

**실수 리터럴**

소수점이 있는 리터럴은 10진수 실수로 간주

E 또는 e가 있는 리터럴은 10진수 지수와 가수로 간주

**문자 리터럴, 문자형**

작은따옴표(’)로 묶인 텍스트는 하나의 문자 리터럴로 간주

역슬래쉬(\)가 붙은 리터럴은 이스케이프 문자로 인식

**문자열 리터럴**

큰따옴표(”)로 묶인 텍스트는 문자열 리터럴로 간주, String

**논리 리터럴, 논리형**

true 와 false는 논리 리터럴로 간주하고, 논리 리터럴을 저장할 수 있는 변수 타입은 boolean 하나 뿐

**변수의 사용 범위**

중괄호{} 블록 내에서 선언되고 사용됨

**데이터 타입**

변수를 선언할 때 주어진 타입은 변수를 사용하는 도중에 변경할 수 없다.

## 인코딩과 디코딩(encoding & decoding)

코드화(암호화) / 복호화

- 아스키(ASCII)
- Extended ASCII
- CP
- Unicode

## Overflow

해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것

```java
// 예시, 부호가 있는 정수는 부호비트가 0에서 1로 바뀔때 오버플로우가 발생
// 최대값 + 1 -> 최소값
// 최소값 - 1 -> 최대값
```

실수형의 경우 오버플로우가 발생하면 값이 무한대가 되며, 정수형에 없는 underflow가 존재

underflow: 실수형으로 표현할 수 없는 작은 값이 되는 경우 변수의 값은 0으로 변환

- 정확한 계산을 위해서는 **BigDecimal** 사용(java.math)

## **타입의 변환**

타입의 변환은 자동(묵시적)변환과 강제(명시적)변환이 있다.

- boolean으 제외한 나머지 7개의 기본형은 서로 형변환 가능
- 기본형과 참조형은 서로 형변환 불가
- 서로 다른 타입의 변수간 연산은 형변환이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.

**자동 타입 변환**

작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생한다(**기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환**).

특이사항 long(8byte)보다 float(4byte)이 값의 범위가 더 크다

실수 타입은 변환시 정수값이 후에 자동으로 .0이 붙는다.

**강제 타입 변환**

**Casting**이라고 한다.

**연산식에서의 자동 타입 변환**

연산은 기본적으로 같은 타입의 피연산자(operand) 간에만 수행되기 때문에 서로 다른 타입의 피연산자가 있을 경우 두 피연산자 중 크기가 큰 타입으로 자동 변환된 후 연산을 수행한다.

String의 덧셈연산의 경우 앞뒤로 어떤 타입이 오더라도 결과값은 문자열이 됨

# Chapter 03. 연산자

## 1.1 연산자와 피연산자

연산자(Operator): 특정 기능을 수행하는 기호

피연산자(Operand): 연산자의 작업 대상

## 1.3 연산자의 종류

- 단항연산자
- 비교연산자
- 논리연산자
- 대입연산자
- 기타(형변환, 삼항, instanceof 연산자)

## 1.4 연산자의 우선순위와 결합규칙

- 단항연산자가 이항연산자보다 우선순위가 높다
- 일반적인 산술규칙을 따름
- 대입연산자가 제일 우선순위가 낮다
    
    ### 산술 > 비교 > 논리 > 대입
    

### 연산자의 결합규칙

하나의 식에 같은 우선순위의 연산자들이 여러 개 있는 경우, 결합규칙에 의해 연산

- 연산 진행방향은 좌 → 우, 대입만 우 → 좌

## 1.5 산술 변환

연산 수행 직전에 발생하는 피연산자의 자동 형변환

- 두 피연산자의 타입을 같게 일치시킴
- 피연산자의 타입이 int보다 작은 타입인 경우, int로 변환

## 2.1 증감연산자

피연산자에 저장된 값을 1 증가 또는 감소(++, —)

전위형: 값이 참조되기 전에 증감

후위형: 값이 참조된 후에 증감

## 3. 사칙연산자

## 4. 비교 연산자

두 피연산자의 크기를 비교한데 사용하는 연산자

주로 조건문과 반복문의 조건에 사용

연산 결과는 오직 **true** or **false**

## 4.2 등가비교 연산자 ==, !=

```java
// java String의 경우 등가비교 연산자로 문자열이 같은지 판별할 수 없음
// 문자열이 같은지 판단하기 위해서는 equals()를 사용
String sWord1 = "word1";
String sWord2 = "word2";

// ==, 주소를 비교
System.out.println(sWord1 == sWord2); // false
System.out.println(sWord1.equals(sWord2)); // true

// equals(), 문자열을 비교(객체가 달라도 내용이 같으면 true)
if(null == sWord1 || "".equals(sWord1)) {
	throw new Exception("sWord1 확인");
}

if(sWord1 == null || sWord1.equals("")) {
	throw new Exception("sWord1 확인");	
}

// 로직은 try catch 안에서 수행
```

==: 주소 비교

equals(): 대소문자 구별

equalsIgnoreCase(): 대소문자 구별하지 않음

## 5.1 논리연산자 &&, ||, !

**||**: or

**&&**: and

**!**: not

```java
// 여러 연산자의 전체 부정(!)인 경우 각 요소의 역을 생각하면 됨
ch < 'a' || ch > 'z'    <->    'a' <= ch && ch <= 'z'
```

## 5.2 비트연산자 &, |, ^, ~, <<, >>

**|**: or

**&**: and

**^**: XOR, 피연산자의 **값이 서로 다를때**만 1의 결과값, 같을 때는 0

**~**: 0은 1로, 1은 0으로 논리부정 연산자와 유사

**<<, >>**: 쉬프트연산자, 2진수의 각 자리 값을 좌(<<), 우(>>)로 이동

양수의 경우 빈칸 0, 음수의 경우 빈칸 1로 채움

```java
byte p = 10;
byte n = -10;

~p // -11
~p + 1 // -10
~~p = 10
~(n-1) // 10
```

## 6.1 조건 연산자 ? :

if 문과 동일

`조건식 ? 식1 : 식2`

## 소감