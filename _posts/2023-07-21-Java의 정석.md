---
title:  "[Book] Java의 정석"
excerpt: "Java"

categories:
  - IT
tags:
  - [IT, Java]

toc: true   # table of contents
toc_sticky: true

author_profile: false   # 좌측 프로필 접기(포스트에 들어가면 꺼짐)
sidebar:
  nav: "docs"

date: 2023-07-21
last_modified_at: 2022-07-23
---

## **변수(Variable)**

데이터는 메모리에 저장된다.

**값을 저장할 수 있는 메모리의 공간**을 의미함.

변수는 복수 개의 값을 저장할 수 없고, 하나의 값만 저장 가능하다.

## **변수의 선언**

**타입**은 변수에 저장되는 값의 종류와 범위를 결정짓는 요소

변수 이름은 **메모리 주소에 붙여진 이름**이다.

```java
int age;
//변수타입 변수이름

//초기화: 변수를 사용하기 전 처음으로 값을 저장하는 것
int age = 25;
// 초기화를 하지 않는 경우 쓰레기값이 남아 있을 수 있어 주의
```

변수명은 naming convention에 따라야 한다.

### Naming convention

- 첫번째 글자는 문자이거나 $, _ 이어야하고 숫자로 시작할 할 수 없다.
- 대소문자 구분된다.
- 길이 제한은 없다.
- 자바 예약어는 사용할 수 없다.

변수명은 해당 이름을 보고 이 변수가 어떤 값을 저장하는지 쉽게 알 수 있도록 하는것이 좋다.

### Java  권장 명명규칙(관례)

- 클래스 이름의 첫 글자는 대문자
- 상수의 이름은 대문자, 여러 단어가 연결된 경우 _로 구분
- 첫 문자는 소문자로 시작하고 다른 단어가 붙을 경우 첫 문자를 대문자로 한다

## 변수의 타입

기본형과 참조형이 존재

기본형: 실제 값을 저장

참조형: 객체의 주소를 저장

**변수값 저장**

변수 값을 저장할때는 대입연산자(=)를 사용한다.

## 상수와 리터럴

상수(Constant): 값을 저장할 수 있는 공간이지만, **한번 저장하면 다른 값으로 변경할 수 없다**.

반드시 선언과 동시에 초기화해야함

final 키워드를 사용하여 선언

```java
final int MAX_SPEED = 10;
```

리터럴(Literal): 원래는 일반적인 값 그 자체가 상수를 뜻하지만, 위에 한번 선언하면 변경할 수 없는 저장공간(Constant)과 비교하기 위해 붙인 이름

### **정수 타입(byte, char, short, int, long)**

**int**

자바는 **기본적으로 정수 연산을 int 타입**으로 수행

저장하려는 변수가 특별한 이유가 없는 한 int 타입 변수에 저장하는 것이 좋다.(JVM에서 연산할때 4byte로 변환하여 연산, 자체 4byte인 int가 연산에 유리)

**String(reference type)**

String 타입은 기본 타입이 아니다.

String은 클래스 타입이고 String 변수는 참조 변수이다.

문자열이 변수에 직접 저장되는 것이 아니라, String 객체가 생성되고 변수는 객체의 번지를 참조함.

**char**

char 타입에는 ‘’ 빈 문자를 대입시 컴파일 에러 발생, 공백을 저장하고 싶은 경우 유니코드 32로 초기화 해야한다.

**long**

long 타입은 큰 정수값을 저장할때 사용하며, 뒤에 L을 붙여서 사용함(소문자는 1과 혼동하기 쉬워 사용자제)

**double, float**

실수는 부동소수점(floating-point) 방식으로 저장

기본적으로 double로 간주, double이 float 보다 정밀한 계산할때 사용

double 타입은 뒤에 D나 d를 붙여준다.

float 타입은 리터럴 뒤에 f 나 F를 붙여준다.

## 출력

화면에 표출하는 방법

지시자(specifier)를 사용하여 변수도 출력 할 수 있다.

- printf(): 출력만 진행
- println(): 출력 후 줄바꿈

| 지시자 | 설명 |
| --- | --- |
| %b | boolean형식 출력 |
| %d | decimal(10진수) 형식 출력 |
| %o | octal(8진수) 형식 출력 |
| %x, %X | hexa-decimal(16진수) 형식 출력 |
| %f | floating-point 형식 출력 |
| %e. %E | exponent 형식 출력 |
| %c | character 형식 출력 |
| %s | String 출력 |

## 입력

화면에서 값을 입력 받기

```java
import java.util.*;

// Scanner클래스의 객체를 생성
Scanner scanner = new Scanner(System.in)

String input = scanner.nextLine(); // .nextInt()도 가능
int num = Integer.parseInt(input);
```

## 기본형

**정수 리터럴**

소수점 없는 정수는 10진수로 간주

0으로 시작하는 리터럴은 8진수로 간주

0x 또는 0X로 시작하는 리터럴은 16진수로 간주

**실수 리터럴**

소수점이 있는 리터럴은 10진수 실수로 간주

E 또는 e가 있는 리터럴은 10진수 지수와 가수로 간주

**문자 리터럴, 문자형**

작은따옴표(’)로 묶인 텍스트는 하나의 문자 리터럴로 간주

역슬래쉬(\)가 붙은 리터럴은 이스케이프 문자로 인식

**문자열 리터럴**

큰따옴표(”)로 묶인 텍스트는 문자열 리터럴로 간주, String

**논리 리터럴, 논리형**

true 와 false는 논리 리터럴로 간주하고, 논리 리터럴을 저장할 수 있는 변수 타입은 boolean 하나 뿐

**변수의 사용 범위**

중괄호{} 블록 내에서 선언되고 사용됨

**데이터 타입**

변수를 선언할 때 주어진 타입은 변수를 사용하는 도중에 변경할 수 없다.

## 인코딩과 디코딩(encoding & decoding)

코드화(암호화) / 복호화

- 아스키(ASCII)
- Extended ASCII
- CP
- Unicode

## Overflow

해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것

```java
// 예시, 부호가 있는 정수는 부호비트가 0에서 1로 바뀔때 오버플로우가 발생
// 최대값 + 1 -> 최소값
// 최소값 - 1 -> 최대값
```

실수형의 경우 오버플로우가 발생하면 값이 무한대가 되며, 정수형에 없는 underflow가 존재

underflow: 실수형으로 표현할 수 없는 작은 값이 되는 경우 변수의 값은 0으로 변환

- 정확한 계산을 위해서는 **BigDecimal** 사용(java.math)

## **타입의 변환**

타입의 변환은 자동(묵시적)변환과 강제(명시적)변환이 있다.

- boolean으 제외한 나머지 7개의 기본형은 서로 형변환 가능
- 기본형과 참조형은 서로 형변환 불가
- 서로 다른 타입의 변수간 연산은 형변환이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.

**자동 타입 변환**

작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생한다(**기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환**).

특이사항 long(8byte)보다 float(4byte)이 값의 범위가 더 크다

실수 타입은 변환시 정수값이 후에 자동으로 .0이 붙는다.

**강제 타입 변환**

**Casting**이라고 한다.

**연산식에서의 자동 타입 변환**

연산은 기본적으로 같은 타입의 피연산자(operand) 간에만 수행되기 때문에 서로 다른 타입의 피연산자가 있을 경우 두 피연산자 중 크기가 큰 타입으로 자동 변환된 후 연산을 수행한다.

String의 덧셈연산의 경우 앞뒤로 어떤 타입이 오더라도 결과값은 문자열이 됨

# Chapter 03. 연산자

## 1.1 연산자와 피연산자

연산자(Operator): 특정 기능을 수행하는 기호

피연산자(Operand): 연산자의 작업 대상

## 1.3 연산자의 종류

- 단항연산자
- 비교연산자
- 논리연산자
- 대입연산자
- 기타(형변환, 삼항, instanceof 연산자)

## 1.4 연산자의 우선순위와 결합규칙

- 단항연산자가 이항연산자보다 우선순위가 높다
- 일반적인 산술규칙을 따름
- 대입연산자가 제일 우선순위가 낮다
    
    ### 산술 > 비교 > 논리 > 대입
    

### 연산자의 결합규칙

하나의 식에 같은 우선순위의 연산자들이 여러 개 있는 경우, 결합규칙에 의해 연산

- 연산 진행방향은 좌 → 우, 대입만 우 → 좌

## 1.5 산술 변환

연산 수행 직전에 발생하는 피연산자의 자동 형변환

- 두 피연산자의 타입을 같게 일치시킴
- 피연산자의 타입이 int보다 작은 타입인 경우, int로 변환

## 2.1 증감연산자

피연산자에 저장된 값을 1 증가 또는 감소(++, —)

전위형: 값이 참조되기 전에 증감

후위형: 값이 참조된 후에 증감

## 3. 사칙연산자

## 4. 비교 연산자

두 피연산자의 크기를 비교한데 사용하는 연산자

주로 조건문과 반복문의 조건에 사용

연산 결과는 오직 **true** or **false**

## 4.2 등가비교 연산자 ==, !=

```java
// java String의 경우 등가비교 연산자로 문자열이 같은지 판별할 수 없음
// 문자열이 같은지 판단하기 위해서는 equals()를 사용
String sWord1 = "word1";
String sWord2 = "word2";

// ==, 주소를 비교
System.out.println(sWord1 == sWord2); // false
System.out.println(sWord1.equals(sWord2)); // true

// equals(), 문자열을 비교(객체가 달라도 내용이 같으면 true)
if(null == sWord1 || "".equals(sWord1)) {
	throw new Exception("sWord1 확인");
}

if(sWord1 == null || sWord1.equals("")) {
	throw new Exception("sWord1 확인");	
}

// 로직은 try catch 안에서 수행
```

==: 주소 비교

equals(): 대소문자 구별

equalsIgnoreCase(): 대소문자 구별하지 않음

## 5.1 논리연산자 &&, ||, !

**||**: or

**&&**: and

**!**: not

```java
// 여러 연산자의 전체 부정(!)인 경우 각 요소의 역을 생각하면 됨
ch < 'a' || ch > 'z'    <->    'a' <= ch && ch <= 'z'
```

## 5.2 비트연산자 &, |, ^, ~, <<, >>

**|**: or

**&**: and

**^**: XOR, 피연산자의 **값이 서로 다를때**만 1의 결과값, 같을 때는 0

**~**: 0은 1로, 1은 0으로 논리부정 연산자와 유사

**<<, >>**: 쉬프트연산자, 2진수의 각 자리 값을 좌(<<), 우(>>)로 이동

양수의 경우 빈칸 0, 음수의 경우 빈칸 1로 채움

```java
byte p = 10;
byte n = -10;

~p // -11
~p + 1 // -10
~~p = 10
~(n-1) // 10
```

## 6.1 조건 연산자 ? :

if 문과 동일

`조건식 ? 식1 : 식2`


# Chapter 04. 조건문과 반복문

코드는 기본적으로 위에서 아래로 순차적으로 진행되는데, 이런 흐름을 바꾸는 역할을 하는 문장들을 제어문(control statement)라 함

제어문에는 조건문과 반복문 존재

## 1. 조건문 - if, switch

처리할 것이 많은 경우는 switch 문이 효율적이지만, if문에 비해 사용 제약이 많음

## 1.1. if문

조건식의 결과값은 반드시 true or false여야 함

```java
// if문
if(조건식) {
	// 조건식이 true인 경우 수행될 문장
}
```

- [ ]  EnaStudy, 탭과 스페이스바 4번의 차이점 확인
- [ ]  블럭 스타일 뭐가 좋은지 ?

블럭 내 문장이 한줄 뿐인 경우 괄호를 생략할 수 있지만, 가능하면 생략하지 않고 사용하는 것이 가독성에 유리

대부분의 실수는 늘 쉬운 곳에 있다. 이런 실수를 누가 할까? 생각이 드는 실수를 하게된다.

## 1.3 if-else if문

여러 조건을 수행해야 하는 경우 사용하는 조건식

```java
if(조건식1) {
	// 조건식1이 참인 경우 실행
} else if(조건식2) {
	// 조건식2가 참인 경우 실행
} else {
	// 위 조건식이 모두 참이 아닌 경우 실행
}
```

else를 추가함으로써 누락되는 조건들을 처리할 수 있다.

조건식도 위에서 아래로 흐르기 때문에 맨 처음 조건에서 확인을 마친 사항은 아래 조건에서 생략할 수 있다.

```java
// code1과 code2는 같은 코드
// code1
if(score >= 90) {
	grade = "A";
} else if(score >= 80) {
	grade = "B";
} else {}

// code2
if(score >= 90) {
	grade = "A";
} else if(score >= 80 && score < 90) {
	grade = "B";
} else {}
```

## 1.5 switch문

if문의 조건식은 참과 거짓밖에 설정할 수 없기 때문에, 경우의 수가 여러가지인 경우 else-if를 계속 추가해야 하므로 조건식이 많아지고 복잡해짐

처리할 것이 많은 경우 switch문이 효율적이나, switch문은 제약조건이 있다

### switch문 제약조건

- 조건식의 결과는 정수 또는 문자열이여 함
- case문의 값은 정수 상수, 문자열만 가능하고, 중복되지 않아야 함
    
    `정수 상수`: 문자 리터럴(ASCII로 변환이 되서), final이 붙은 정수 상수(e.g. final int ONE = 1; 인경우 ONE 사용 가능), 일반 정수 상수
    

### 특징

- default는 아무 위치에나 작성해도 되지만, 주로 마지막에 작성한다
- default는 생략 가능
- break는 case 영역을 구분하는데 사용, default에서는 break를 사용하지 않아도 됨
- case 조건 여러개를 한번에 설정 가능
    
    ```java
    case 3: case 4: case 5:
    	System.out.println("조건 붙여서 사용 가능");
    	break;
    ```
    

## 2. 반복문 - for, while, do-while

어떤 작업이 반복적으로 수행되도록 설정할때 사용

for, while은 조건에 따라 한번도 수행되지 않을 수 있지만, do-while의 경우 최소 1번의 수행 보장

```java
for(;;) { }    // 초기화, 조건식, 증감식 모두 생략 가능, 조건식은 참으로 간주, 무한 반복
```

### 향상된 for문(enhanced for statement)

배열 또는 컬렉션의 요소 타입으로 반복문을 수행

```java
for( 타입 변수명 : 배열 또는 컬렉션) {
	// 반복할 문장
}
```

## 2.2 while문

조건식과 블럭만으로 이루어진 반복문

조건식이 true인 동안만 동작

```java
while(조건식) {
	// 조건이 참인 경우 동작
}
```

### 특징

- for문과 while은 완벽히 대체 가능
- 초기화나 증감식이 필요하지 않은 경우 while이 더 적합
- while의 경우 조건식이 없으면 동작하지 않음

### 2.4 break문

자신이 포함된 가장 가까운 반복문을 벗어난다.

주로 if문과 함께 사용하여 특정 조건인 경우 반복문을 벗어남

### 2.5 continue문

반복문의 끝으로 이동하여 다음 반복문으로 넘어간다.

### 2.6 이름 붙은 반복문

중첩된 반복문의 경우 이름이 붙어있으면, 특정 반복문에 break를 걸어 여러 반복문을 벗어날 수 있다.

```java
Loop1: for(int i = 2; i <= 9; i++) {
	for(int j = 1; j <= 9; j++) {
		if(j == 5)
			break Loop1;
		break;
	} // end of for i
} // end of Loop1
```

# Chapter 05. 배열 array

## 1.1 배열이란

같은 타입의 여러 변수를 하나의 묶음으로 다루는 것

## 1.2 배열의 선언과 생성

생성을 원하는 타입의 변수 또는 타입에 배열임을 의미하는 대괄호[]를 붙임

```java
// 방법1
int[] score;
String[] name;

// 방법2
int score[];
String name[];

타입[] 변수이름; // 배열을 선언(배열을 다루기 위한 참조변수 선언)
변수이름 = new 타입[길이]; // 배열을 생성(실제 저장공간을 생성)
```

## 1.3 배열의 길이와 인덱스

배열의 각 저장곤간을 배열의 요소(element)라 하며, **배열이름[index]** 형식으로 배열의 요소에 접근함

index의 범위는 **0부터 배열길이 -1** 까지

배열을 다룰 때 주의사항, index 범위를 벗어난 값을 index로 사용하면 **ArrayIndexOutOfBoundException** 발생

- 배열의 길이가 0인 배열도 생성 가능

### 배열이름.length

자바에서 JVM이 모든 배열의 길이를 별도로 관리, .length를 통해서 배열정보 얻을 수 있다

배열은 한번 생성하면 길이를 변경할 수 없기 때문에, 이미 생성한 배열의 길이는 변하지 않는 상수

배열의 각 요소에 접근하는 방식은 for문과 자주 이용

```java
for(int i = 0; i < array.length; i ++) {
	// 반복문
}
```

### 배열의 길이 변경하기

배열은 한번 선언되고 나면 길이를 변경할 수 없기 때문에 새로운 배열을 생성해서 데이터를 옮겨갸아 함

1. 더 큰 배열을 새로 생성
2. 기존 배열의 내용을 새로운 배열에 복사
- [ ]  길이를 2배 정도 선언한다는데, 이것은 상황에 따라 다를 듯

## 1.4 배열의 초기화

### 배열의 출력

.toString() 메서드를 사용하여 배열 출력 가능

바로 배열을 출력할 경우 배열의 주소가 출력되고, 배열에 저장된 값들을 보기 위해서는 .toString() 메서드를 활용

## 1.5 배열의 복사

### for문을 통한 복사

```java
int[] arr = new int[5];
int[] tmp = new int[arr.length * 2];

for(int i = 0; i < arr.length; i++) {
	tmp[i] = arr[i];
}

// 중요, 참조변수 arr이 새로운 배열을 가리키게 한다
arr = tmp;
```

### System.arraycopy()를 이용한 배열의 복사

system 클래스의 .arraycopy()를 사용하면 더 효율적

```java
// num[0]에서 newNum[0]으로 num.lenght개의 데이터를 복사
System.arraycopy(num, 0, newNum, 0, num.length)
```

## 2. String 배열

배열의 타입이 String인 요소를 담는 배열을 생성

String만은 특별히 큰따옴표 만으로도 간략히 초기화 가능

```java
String[] name = new String[3];

// 원래 클래스의 배열일 경우의 초기화, new연산자를 통해 객체를 생성해야 함
name[0] = new String("Kim");
name[1] = new String("Park");
name[2] = new String("Yi");

// String은 큰따옴표 만으로도 객체 생성 및 초기화 가능
name[0] = "Kim";
name[1] = "Park";
name[2] = "Yi";
```

### 2.3 char배열과 String클래스

문자열이라는 용어는 ‘문자를 연이어 늘어놓은 것’이기 때문에 문자배열인 char배열과 String은 같음

Java에서 char배열이 아니는 String을 쓰는 이유는, String에는 메서드가 존재하기 때문

### String클래스의 주요 메서드

- charAt()
    
    문자열에서 지정된 index에 있는 한 문자를 가져옴
    
- length()
    
    문자열의 길이를 구함
    
- substring()
    
    문자열의 일부를 뽑아냄
    
    ```java
    String str = "012345";
    String tmp = str.substring(1, 4); // 123 출력, 마지막 위치는 불포함
    ```
    
- equals()
- toCharArray()
    
    String을 char 배열로 변환
    

## 2.4 커맨드 라인을 통해 입력받기

```java
c:\jdk1.8\work\ch5> java MainTest abc 123
```

위와 같이 터미널에서 입력시에 java JVM으로 MainTest 클래스를 실행시킴

터미널에서 입력된 매개변수는 **공백문자로 구분**됨

공백이 있는 입력값을 적용시킬 경우, 큰따옴표(”)로 감싸서 입력

아무것도 입력하지 않을 경우 참조변수 args의 값은 null일 될테지만, 매번 null 체크를 하는 번거로움을 없애기 위해서 Java는 자체적으로 입력값이 없는 경우 크기가 0인 배열을 선언하고, 해당 값을 입력값으로 함

## 3. 다차원 배열

## 3.2 2차원 배열의 초기화

배열들을 중괄호로 한번 더 감싸서 선언({, })

선언 시에 한 줄에 전부 작성해도 되지만 가독성을 위해 아래와 같이 작성하는 것이 일반적

```java
int[][] arr = {
								{1, 2, 3},
								{4, 5, 6}
							};
// 다차원 배열부터는 어느 차원의 배열의 길이인지에 따라 .length의 출력값이 다름
Sstem.out.println(arr.length);    // 2
Sstem.out.println(arr[0].length);    // 3
```

## 3.2 가변 배열

2차원 이상의 배열을 배열의 배열형태로 처리한다는 사실을 이용하면, 보다 자유로운 형태의 배열 구성 가능

전체 배열 차수 중 마지막 차수의 길이를 지정하지 않고 배열 선언 가능

마지막 배열의 각 행마다 다른 길이의 배열 생성 가능

```java
int[][] score = new int[3][];  // 마지막 차수의 길이를 지정하지 않고 배열 선언 가능
score[0] = new int[4];    // 각 행마다 다른 길이의 배열 생성 가능
score[1] = new int[2];
score[2] = new int[6];
```